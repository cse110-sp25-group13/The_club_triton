<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: card-system.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: card-system.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// Congratulations, you are retired, buddy.
// Get a life, don't study CS in your next life.
// const initialCardData = [
//   {
//     id: "structure001", // Suggest ID reflects type and uniqueness
//     name: "Geisel Library",
//     type: "Structure", // Ensure consistent type naming
//     ranking: 5,
//     rarity: 4,
//     front_image_placeholder: "assets/images/placeholders/geisel_front.png", // Assume placeholder image at this path
//     back_image_placeholder: "assets/images/placeholders/geisel_back.png",
//     description: "The iconic anechoic bird of UCSD's libraries.", // Confirm description content
//   },
//   {
//     id: "dining001",
//     name: "Price Center Food Court",
//     type: "Dining",
//     ranking: 4,
//     rarity: 3,
//     front_image_placeholder: "assets/images/placeholders/pc_food_front.png",
//     back_image_placeholder: "assets/images/placeholders/pc_food_back.png",
//     description: "A place for every craving, and every student.",
//   },
//   {
//     id: "mascot001",
//     name: "King Triton",
//     type: "Mascot",
//     ranking: 5, // Mascot ranking may have a different meaning, or not used for direct comparison
//     rarity: 5,
//     front_image_placeholder: "assets/images/placeholders/triton_front.png",
//     back_image_placeholder: "assets/images/placeholders/triton_back.png",
//     description: "The mighty ruler of the Tritons.",
//   },
//   // Continue to add more cards as required (5 per type, 15 total)...
// ];

// export default initialCardData; // If using ES modules
// or module.exports = initialCardData; // If using CommonJS (Node.js)
// For now, just define it in this file.

let db; // Global variable to hold the database instance (for simplicity; in real projects, use better state management)
let initPromise = null; // Singleton pattern to ensure only one initialization happens
const DB_NAME = "UCSDCardsDB";
const DB_VERSION = 1; // Database version
const STORE_NAME = "cards"; // Object store name

/**
 * Asynchronously fetch card data from the specified JSON file path.
 * @param {string} jsonFilePath - The path to the JSON file.
 * @returns {Promise&lt;Array&lt;Object>>} A Promise that resolves to an array of card objects.
 */
async function fetchCardDataFromJson(jsonFilePath) {
  try {
    const response = await fetch(jsonFilePath);
    if (!response.ok) {
      // If HTTP status code is not 2xx (e.g., 404 Not Found, 500 Server Error)
      throw new Error(
        `Network response was not ok: ${response.status} ${response.statusText}`,
      );
    }
    const jsonData = await response.json(); // Parse JSON response body
    console.log(
      `Successfully fetched and parsed card data from ${jsonFilePath}`,
    );
    return jsonData;
  } catch (error) {
    console.error(
      `Failed to fetch or parse card data from ${jsonFilePath}:`,
      error,
    );
    throw error; // Re-throw error for caller to handle
  }
}

/**
 * Check if the 'cards' object store is empty, and if so, load and populate data from JSON file.
 * @param {IDBDatabase} databaseInstance - The opened database instance.
 * @returns {Promise&lt;void>}
 */
function populateDataIfEmpty(databaseInstance) {
  return new Promise((resolve, reject) => {
    (async () => {
      try {
        // 1. Start a readonly transaction to check data count
        const checkTransaction = databaseInstance.transaction(
          [STORE_NAME],
          "readonly",
        );
        const objectStoreForCheck = checkTransaction.objectStore(STORE_NAME);
        const countRequest = objectStoreForCheck.count();

        // Handle the async nature of countRequest using its callbacks
        countRequest.onsuccess = async () => {
          const cardCount = countRequest.result;
          console.log(`Current card count in store: ${cardCount}`);

          if (cardCount === 0) {
            console.log(
              "Card store is empty, attempting to populate from JSON...",
            );
            try {
              const cardsToLoad = await fetchCardDataFromJson(
                "../card-data/cards.json",
              );

              if (cardsToLoad &amp;&amp; cardsToLoad.length > 0) {
                // 2. Start a new readwrite transaction to populate data
                const populateTransaction = databaseInstance.transaction(
                  [STORE_NAME],
                  "readwrite",
                );
                const objectStoreForPopulate =
                  populateTransaction.objectStore(STORE_NAME);

                console.log(
                  `Populating object store with ${cardsToLoad.length} cards from JSON...`,
                );

                const addPromises = cardsToLoad.map((card) => {
                  return new Promise((addResolve, addReject) => {
                    const addRequest = objectStoreForPopulate.add(card);
                    addRequest.onsuccess = () => {
                      console.log(`Card "${card.name}" added from JSON.`);
                      addResolve();
                    };
                    addRequest.onerror = (errEvent) => {
                      console.error(
                        `Error adding card "${card.name}" from JSON:`,
                        errEvent.target.error,
                      );
                      addReject(errEvent.target.error);
                    };
                  });
                });

                await Promise.all(addPromises);
                console.log(
                  "All initial cards successfully added to the object store from JSON.",
                );

                populateTransaction.oncomplete = () => {
                  console.log("Data population transaction completed.");
                  resolve(); // Main Promise resolve
                };
                populateTransaction.onerror = (event) => {
                  console.error(
                    "Data population transaction error:",
                    event.target.error,
                  );
                  reject(event.target.error); // Main Promise reject
                };
              } else {
                console.log(
                  "No card data found in JSON file or JSON was empty.",
                );
                resolve(); // JSON is empty, still considered complete
              }
            } catch (fetchError) {
              console.error(
                "Error fetching/populating data in populateDataIfEmpty:",
                fetchError,
              );
              reject(fetchError); // Main Promise reject
            }
          } else {
            console.log("Card store is not empty, no need to populate.");
            resolve(); // No need to populate, directly complete
          }
        };

        countRequest.onerror = (event) => {
          console.error("Error counting cards:", event.target.error);
          reject(event.target.error); // Main Promise reject
        };
      } catch (transactionError) {
        console.error(
          "Error starting transaction in populateDataIfEmpty:",
          transactionError,
        );
        reject(transactionError); // Main Promise reject
      }
    })(); // Immediately execute this IIFE
  });
}

/**
 * Initialize the IndexedDB database.
 * Uses singleton pattern to ensure only one initialization happens.
 * If the database or object store does not exist, create them and populate with initial data.
 * @returns {Promise&lt;IDBDatabase>}
 */
function initDB() {
  if (initPromise) {
    // If already initializing or completed, return the existing Promise
    return initPromise;
  }

  initPromise = new Promise((resolve, reject) => {
    // 1. Open the database
    const request = window.indexedDB.open(DB_NAME, DB_VERSION);

    // Triggered when the database is successfully opened
    request.onsuccess = async (event) => {
      // Mark callback as async
      db = event.target.result; // Save the database instance to the global variable
      console.log(
        `Successfully opened database: ${DB_NAME} version ${db.version}`,
      );

      try {
        // After database opens successfully, check and populate data if needed
        await populateDataIfEmpty(db);
        console.log(
          "Database initialization and data population check complete.",
        );
        resolve(db); // Resolve after all operations complete
      } catch (populateError) {
        console.error("Error during populateDataIfEmpty:", populateError);
        // If populateDataIfEmpty fails, the initDB Promise should also reject
        reject(populateError);
      }
    };

    // Triggered when a higher version is requested or the database is created for the first time
    request.onupgradeneeded = (event) => {
      const currentDb = event.target.result; // Use local variable instead of global
      console.log(`Upgrade needed or database creation for: ${DB_NAME}`);

      // Create object store if it doesn't exist
      if (!currentDb.objectStoreNames.contains(STORE_NAME)) {
        // Use 'id' property as the primary key (keyPath) - call directly without assignment
        currentDb.createObjectStore(STORE_NAME, { keyPath: "id" });
        console.log(`Object store "${STORE_NAME}" created.`);

        // Data population will be handled separately after database opens successfully
      }
    };

    // Triggered when opening the database fails
    request.onerror = (event) => {
      console.error(`Database error: ${event.target.errorCode}`);
      reject(event.target.errorCode);
    };
  });

  return initPromise;
}

// Call this function on app startup to initialize the database
// For example, in a main JS file or after DOMContentLoaded
// window.addEventListener('DOMContentLoaded', () => {
//   initDB().then(database => {
//     console.log('DB initialized!', database);
//     // Now you can use the db object for other operations
//   }).catch(error => {
//     console.error('Failed to initialize DB:', error);
//   });
// });

// Comment out auto-call for now; will call it at the appropriate place

initDB();

/**
 * Get all card data from the 'cards' object store in IndexedDB.
 * @returns {Promise&lt;Array&lt;Object>>} A Promise that resolves to an array of all card objects
 */
function getAllCards() {
  return new Promise((resolve, reject) => {
    // Ensure the database is initialized and available
    if (!db) {
      console.error("Database not initialized. Call initDB() first.");
      // Optionally, you could try to auto-call initDB() here, but be careful with async flow
      // initDB().then(() => getAllCards().then(resolve).catch(reject)).catch(reject);
      reject("Database not initialized.");
      return;
    }

    // 1. Start a readonly transaction for the 'cards' object store
    const transaction = db.transaction([STORE_NAME], "readonly");

    // 2. Get a reference to the 'cards' object store from the transaction
    const objectStore = transaction.objectStore(STORE_NAME);

    // 3. Use getAll() to fetch all records from the object store
    const request = objectStore.getAll();

    // 4. Handle the request result (async)
    request.onsuccess = (event) => {
      // event.target.result is the array of all card objects
      console.log("Successfully retrieved all cards:", event.target.result);
      resolve(event.target.result); // Promise resolves with the card array
    };

    request.onerror = (event) => {
      console.error("Error retrieving all cards:", event.target.error);
      reject(event.target.error); // Promise rejects with error info
    };

    // (Optional) Listen for transaction complete event, useful for debugging or ensuring all operations are committed
    transaction.oncomplete = () => {
      console.log('Transaction "getAllCards" completed.');
    };

    transaction.onerror = (event) => {
      console.error('Transaction error in "getAllCards":', event.target.error);
      // If the transaction itself fails, also reject the Promise
      // If request.onerror didn't catch it, this is the last line of defense
      if (!request.error) {
        // Avoid duplicate rejects
        reject(event.target.error);
      }
    };
  });
}

/**
 * Get a single card by ID from the 'cards' object store in IndexedDB
 * @param {string} cardId The ID of the card to fetch
 * @returns {Promise&lt;Object|undefined>} A Promise that resolves to the card object, or undefined if not found
 */
function getCardById(cardId) {
  return new Promise((resolve, reject) => {
    if (!db) {
      console.error(
        "Database not initialized for getCardById. Call initDB() first.",
      );
      reject("Database not initialized.");
      return;
    }

    // 1. Start a readonly transaction
    const transaction = db.transaction([STORE_NAME], "readonly");
    // 2. Get object store reference
    const objectStore = transaction.objectStore(STORE_NAME);

    // 3. Use get() to fetch a single record by primary key (keyPath, our 'id')
    const request = objectStore.get(cardId);

    // 4. Handle the request result
    request.onsuccess = (event) => {
      // event.target.result is the found card object, or undefined if not found
      const card = event.target.result;
      if (card) {
        console.log(`Successfully retrieved card with ID "${cardId}":`, card);
      } else {
        console.log(`Card with ID "${cardId}" not found.`);
      }
      resolve(card); // Always resolve, caller decides what to do with result
    };

    request.onerror = (event) => {
      console.error(
        `Error retrieving card with ID "${cardId}":`,
        event.target.error,
      );
      reject(event.target.error);
    };

    transaction.oncomplete = () => {
      console.log(`Transaction "getCardById" for ID "${cardId}" completed.`);
    };

    transaction.onerror = (event) => {
      console.error(
        `Transaction error in "getCardById" for ID "${cardId}":`,
        event.target.error,
      );
      if (!request.error) {
        reject(event.target.error);
      }
    };
  });
}

// After ensuring initDB() is complete, try in the console:

// 1. Call initDB and wait for it to finish
initDB()
  .then(() => {
    console.log("DB is ready for reading tests!");

    // Test getAllCards()
    getAllCards()
      .then((allCards) => {
        console.log("--- All Cards ---");
        console.table(allCards); // console.table() displays object arrays nicely
      })
      .catch((error) => {
        console.error("Error in getAllCards test:", error);
      });

    // Test getCardById() - assuming you have a card with id 'structure001'
    getCardById("structure_001")
      .then((card) => {
        console.log("--- Card by ID (structure_001) ---");
        if (card) {
          console.log(card);
        } else {
          console.log("Card not found!");
        }
      })
      .catch((error) => {
        console.error("Error in getCardById test (structure001):", error);
      });

    // Test fetching a non-existent card ID
    getCardById("nonexistent000")
      .then((card) => {
        console.log("--- Card by ID (nonexistent000) ---");
        if (card) {
          console.log(card);
        } else {
          console.log("Card (nonexistent000) not found, as expected.");
        }
      })
      .catch((error) => {
        console.error("Error in getCardById test (nonexistent000):", error);
      });
  })
  .catch((error) => {
    console.error("DB initialization failed, cannot run read tests:", error);
  });
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#fetchCardDataFromJson">fetchCardDataFromJson</a></li><li><a href="global.html#getAllCards">getAllCards</a></li><li><a href="global.html#getCardById">getCardById</a></li><li><a href="global.html#initDB">initDB</a></li><li><a href="global.html#populateDataIfEmpty">populateDataIfEmpty</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Mon May 26 2025 06:25:49 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
